/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const fsPath = require('path');

const JSZip = require('jszip');
/**
 * A utility to persist templates to data sources.
 * @class
 * @abstract
 * @private
 */


class TemplateSaver {
  /**
   * Persists this template to a Cicero Template Archive (cta) file.
   * @param {Template} template - the template to persist
   * @param {string} [language] - target language for the archive (should be 'ergo')
   * @param {Object} [options] - JSZip options
   * @param {Buffer} logoBuffer - Bytes data of the PNG file
   * @return {Promise<Buffer>} the zlib buffer
   */
  static toArchive(template, language, options) {
    return _asyncToGenerator(function* () {
      if (!language || typeof language !== 'string') {
        throw new Error('language is required and must be a string');
      }

      const metadata = template.getMetadata().createTargetMetadata(language);
      let zip = new JSZip();
      let packageFileContents = JSON.stringify(metadata.getPackageJson());
      zip.file('package.json', packageFileContents, options); // save the grammar

      zip.file('text/', null, Object.assign({}, options, {
        dir: true
      }));

      if (template.getParserManager().getTemplate()) {
        zip.file('text/grammar.tem.md', template.getParserManager().getTemplate(), options);
      } // save the README.md if present


      if (metadata.getREADME()) {
        zip.file('README.md', metadata.getREADME(), options);
      } // save the logo.png if present


      if (metadata.getLogo()) {
        zip.file('logo.png', metadata.getLogo(), Object.assign({
          binary: true
        }, options));
      } // Save the sample files


      const sampleFiles = metadata.getSamples();

      if (sampleFiles) {
        Object.keys(sampleFiles).forEach(function (locale) {
          let fileName;

          if (locale === 'default') {
            fileName = 'text/sample.md';
          } else {
            fileName = "text/sample_".concat(locale, ".md");
          }

          zip.file(fileName, sampleFiles[locale], options);
        });
      } // save the request.json if present & not text-only


      if (metadata.getRequest()) {
        let requestFileContents = JSON.stringify(metadata.getRequest());
        zip.file('request.json', requestFileContents, options);
      }

      let modelFiles = template.getModelManager().getModels();
      zip.file('model/', null, Object.assign({}, options, {
        dir: true
      }));
      modelFiles.forEach(function (file) {
        zip.file('model/' + file.name, file.content, options);
      });
      zip.file('logic/', null, Object.assign({}, options, {
        dir: true
      }));
      const scriptFiles = template.getScriptManager().getScriptsForTarget(language);
      scriptFiles.forEach(function (file) {
        let fileIdentifier = file.getIdentifier();
        let fileName = fsPath.basename(fileIdentifier);
        zip.file('logic/' + fileName, file.contents, options);
      });
      return zip.generateAsync({
        type: 'nodebuffer'
      }).then(something => {
        return Promise.resolve(something).then(result => {
          return result;
        });
      });
    })();
  }

}

module.exports = TemplateSaver;