/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict'; // const CiceroMarkTransformer = require('@accordproject/markdown-cicero').CiceroMarkTransformer;

/**
 * Converts a commonmark model instance to an html string.
 *
 */

class ToHtmlStringVisitor {
  /**
   * Construct the visitor
   * @param {*} [options] configuration options
   */
  constructor(options) {
    this.options = options;
  }
  /**
   * Visits a sub-tree and return the html
   * @param {*} visitor the visitor to use
   * @param {*} thing the node to visit
   * @param {*} [parameters] optional parameters
   * @returns {string} the html for the sub tree
   */


  static visitChildren(visitor, thing, parameters) {
    if (!parameters) {
      parameters = {};
      parameters.result = '';
      parameters.first = false;
      parameters.indent = 0;
    }

    if (thing.nodes) {
      thing.nodes.forEach(node => {
        node.accept(visitor, parameters);
      });
    }

    return parameters.result;
  }
  /**
   * Visit a node
   * @param {*} thing the object being visited
   * @param {*} parameters the parameters
   */


  visit(thing, parameters) {
    switch (thing.getType()) {
      case 'Clause':
        {
          let attributes = "class=\"clause\" name=\"".concat(thing.name, "\"");

          if (thing.elementType) {
            attributes += " elementType=\"".concat(thing.elementType, "\"");
          }

          if (thing.src) {
            attributes += " src=\"".concat(thing.src, "\"");
          }

          parameters.result += "<div ".concat(attributes, ">\n").concat(ToHtmlStringVisitor.visitChildren(this, thing), "</div>\n");
        }
        break;

      case 'Variable':
        {
          let attributes = "class=\"variable\" name=\"".concat(thing.name, "\"");

          if (thing.elementType) {
            attributes += " elementType=\"".concat(thing.elementType, "\"");
          }

          if (thing.identifiedBy) {
            attributes += " identifiedBy=\"".concat(thing.identifiedBy, "\"");
          }

          parameters.result += "<span ".concat(attributes, ">").concat(thing.value, "</span>");
        }
        break;

      case 'FormattedVariable':
        {
          let attributes = "class=\"variable\" name=\"".concat(thing.name, "\" format=\"").concat(thing.format, "\"");

          if (thing.elementType) {
            attributes += " elementType=\"".concat(thing.elementType, "\"");
          }

          if (thing.identifiedBy) {
            attributes += " identifiedBy=\"".concat(thing.identifiedBy, "\"");
          }

          parameters.result += "<span ".concat(attributes, ">").concat(thing.value, "</span>");
        }
        break;

      case 'EnumVariable':
        {
          const enumValues = encodeURIComponent(JSON.stringify(thing.enumValues));
          let attributes = "class=\"variable\" name=\"".concat(thing.name, "\" enumValues=\"").concat(enumValues, "\"");

          if (thing.elementType) {
            attributes += " elementType=\"".concat(thing.elementType, "\"");
          }

          if (thing.identifiedBy) {
            attributes += " identifiedBy=\"".concat(thing.identifiedBy, "\"");
          }

          parameters.result += "<span ".concat(attributes, ">").concat(thing.value, "</span>");
        }
        break;

      case 'Conditional':
        parameters.result += "<span class=\"conditional\" name=\"".concat(thing.name, "\" whenTrue=\"").concat(thing.whenTrue[0] ? thing.whenTrue[0].text : '', "\" whenFalse=\"").concat(thing.whenFalse[0] ? thing.whenFalse[0].text : '', "\">").concat(thing.nodes[0] ? thing.nodes[0].text : '', "</span>");
        break;

      case 'Optional':
        parameters.result += "<span class=\"optional\" name=\"".concat(thing.name, "\" whenSome=\"").concat(thing.whenSome[0] ? thing.whenSome[0].text : '', "\" whenNone=\"").concat(thing.whenNone[0] ? thing.whenNone[0].text : '', "\">").concat(thing.nodes[0] ? thing.nodes[0].text : '', "</span>");
        break;

      case 'Formula':
        {
          let attributes = "class=\"formula\" name=\"".concat(thing.name, "\"");

          if (thing.code) {
            attributes += " code=\"".concat(encodeURIComponent(thing.code), "\"");
          }

          if (thing.dependencies) {
            attributes += " dependencies=\"".concat(encodeURIComponent(JSON.stringify(thing.dependencies)), "\"");
          }

          parameters.result += "<span ".concat(attributes, ">").concat(thing.value, "</span>");
        }
        break;

      case 'CodeBlock':
        {
          const info = thing.info;

          if (info) {
            parameters.result += "<pre class=\"code_block\"><code data-ciceromark=\"".concat(encodeURIComponent(thing.info), "\">").concat(thing.text, "</pre></code>\n");
          } else {
            parameters.result += "<pre class=\"code_block\"><code>".concat(thing.text, "</pre></code>\n");
          }
        }
        break;

      case 'Code':
        parameters.result += "<code>".concat(thing.text, "</code>");
        break;

      case 'HtmlInline':
        parameters.result += "<span class=\"html_inline\">".concat(thing.text, "</span>");
        break;

      case 'Emph':
        parameters.result += "<em>".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</em>");
        break;

      case 'Strong':
        parameters.result += "<strong>".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</strong>");
        break;

      case 'BlockQuote':
        {
          parameters.result += "<blockquote>".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</blockquote>\n");
        }
        break;

      case 'Heading':
        {
          const level = parseInt(thing.level);
          parameters.result += "<h".concat(level, ">").concat(ToHtmlStringVisitor.visitChildren(this, thing), "</h").concat(level, ">\n");
        }
        break;

      case 'ThematicBreak':
        parameters.result += '\n<hr>\n';
        break;

      case 'Linebreak':
        parameters.result += '<br>';
        break;

      case 'Softbreak':
        parameters.result += '\n';
        break;

      case 'Link':
        parameters.result += "<a href=\"".concat(thing.destination, "\" title=").concat(thing.title, ">").concat(ToHtmlStringVisitor.visitChildren(this, thing), "</a>");
        break;

      case 'Image':
        parameters.result += "<img src=\"".concat(thing.destination, "\" title=\"").concat(thing.title, "\"/>");
        break;

      case 'Paragraph':
        parameters.result += "<p>".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</p>\n");
        break;

      case 'HtmlBlock':
        {
          parameters.result += "<pre class=\"html_block\"><code>".concat(thing.text, "</pre></code>\n");
          break;
        }

      case 'Text':
        parameters.result += "".concat(thing.text);
        break;

      case 'List':
        {
          // Always start with a new line
          parameters.result += '\n';
          const {
            delimiter,
            start,
            tight
          } = thing;

          if (thing.type === 'ordered') {
            parameters.result += "<ol delimiter=".concat(delimiter, " start=").concat(start, " tight=").concat(tight, ">");
          } else {
            parameters.result += "<ul tight=".concat(tight, ">");
          }

          thing.nodes.forEach(item => {
            parameters.result += "\n<li>".concat(ToHtmlStringVisitor.visitChildren(this, item), "</li>");
          });

          if (thing.type === 'ordered') {
            parameters.result += '</ol>';
          } else {
            parameters.result += '</ul>';
          }
        }
        break;

      case 'Item':
        parameters.result += "<li>".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</li>\n");
        break;

      case 'Document':
        parameters.result += "<html>\n<body>\n<div class=\"document\">\n".concat(ToHtmlStringVisitor.visitChildren(this, thing), "</div>\n</body>\n</html>");
        break;

      default:
        throw new Error("Unhandled type ".concat(thing.getType()));
    }

    parameters.first = false;
  }

}

module.exports = ToHtmlStringVisitor;